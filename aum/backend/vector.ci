// Copyright (C) 2022 Nikunj Gupta
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
//  Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along
// with this program. If not, see <https://www.gnu.org/licenses/>.

module Vector
{
    include "eigen3/Eigen/Core";

    include "aum/util/sizes.hpp";

    include "cmath";

    extern module Scalar;

    message part_vector_msg;

    array[1D] Vector
    {
        ////////////////////////////////////////////////////////////////////////
        // Basic Constructors                                                 //
        ////////////////////////////////////////////////////////////////////////
        entry Vector(int, int);  // Size
        entry Vector(int, double, int);  // Size, Value

        ////////////////////////////////////////////////////////////////////////
        // Operation over vector                                              //
        ////////////////////////////////////////////////////////////////////////
        entry void initialize_operation()
        {
            for (; WRITE_TAG > -1;)
            {
                case
                {
                    // Operation Add:
                    // The generalized addition operation takes two vectors
                    // as arguments and updates the current vector with the
                    // sum of the two vectors.
                    when
                        add[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1]),
                        input_vector_2[WRITE_TAG](int write_tag, int size2, double arr2[size2])
                    {
                        serial "vector_addition"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);
                            evec_t e2(arr2, size2);

                            evec_t e(vec.data(), vec.size());

                            e = e1 + e2;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation Add:
                    // The generalized addition operation takes one vector
                    // as argument and updates the current vector.
                    when
                        plus_add[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1])
                    {
                        serial "vector_single_addition"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);

                            evec_t e(vec.data(), vec.size());

                            e += e1;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation Subtract:
                    // The generalized subtraction operation takes two vectors
                    // as arguments and updates the current vector with the
                    // sum of the two vectors.
                    when
                        subtract[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1]),
                        input_vector_2[WRITE_TAG](int write_tag, int size2, double arr2[size2])
                    {
                        serial "vector_subtraction"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);
                            evec_t e2(arr2, size2);

                            evec_t e(vec.data(), vec.size());

                            e = e1 - e2;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation subtract:
                    // The generalized subtraction operation takes one vector
                    // as argument and updates the current vector.
                    when
                        minus_subtract[WRITE_TAG](int write_tag, bool inverted),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1])
                    {
                        serial "vector_single_subtraction"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);

                            evec_t e(vec.data(), vec.size());

                            if (inverted)
                                e = e1 - e;
                            else
                                e -= e1;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation dot:
                    // The generalized index wise multiply then reduce
                    when
                        dot[READ_TAG](int read_tag, int scalar_tag, CProxy_Scalar proxy),
                        input_vector_1[READ_TAG](int read_tag, int size, double arr[size])
                    {
                        serial "dot_product"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr, size);
                            evec_t e(vec.data(), vec.size());

                            double val = e.dot(e1);

                            CkCallback cb(CkReductionTarget(Scalar, set_reduced_value), proxy);
                            contribute(sizeof(double), &val, CkReduction::sum_double, cb, scalar_tag);

                            // Since dot produce isn't updating the vector
                            // itself, we consider this operation as a read and
                            // not a write.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation scalar multiply:
                    // The generalized index wise scalar multiply
                    when
                        scalar_multiply[WRITE_TAG](int write_tag, double value),
                        input_vector_1[WRITE_TAG](int write_tag, int size, double arr[size])
                    {
                        serial "scalar_multiply"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;
                        
                            evec_t e(vec.data(), vec.size());
                            evec_t e1(arr, size);

                            e = value * e1;

                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation scalar multiply:
                    // The generalized index wise scalar multiply
                    when
                        aum_scalar_multiply[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size, double arr[size]),
                        input_vector_1[WRITE_TAG](int write_tag, double value)
                    {
                        serial "aum_scalar_multiply"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;
                        
                            evec_t e(vec.data(), vec.size());
                            evec_t e1(arr, size);

                            e = value * e1;

                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Reduction target
                    when
                        assemble_reduced[WRITE_TAG](int write_tag, int offset, int size, double arr[size])
                    {
                        serial "assemble_reduced"
                        {
                            std::memcpy(arr, vec.data() + offset, size);

                            int num_of_divisions = 
                                size / aum::sizes::block_size::value_c;
                            
                            if (size % aum::sizes::block_size::value_c != 0)
                                ++num_of_divisions;

                            // Operation is now complete - set up read facility
                            // on this data.
                            if (++reduction_counter == num_of_divisions)
                            {
                                // All possible reductions have submitted
                                // results. Move to next operation!
                                reduction_counter = 0;
                                ++WRITE_TAG;
                                READ_TAG = WRITE_TAG + 1;
                            }
                        }
                    }

                    // Operation send_to_1:
                    // Helper function to send the value of underlying vector
                    // to the site where an operation is to be performed.
                    when send_to_1[READ_TAG](int read_tag, int write_tag, CProxy_Vector pv)
                    {
                        serial "send_to_1"
                        {
                            pv[thisIndex].input_vector_1(write_tag, vec.size(), vec.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation send_to_2:
                    // Helper function to send the value of underlying vector
                    // to the site where an operation is to be performed.
                    when send_to_2[READ_TAG](int read_tag, int write_tag, CProxy_Vector pv)
                    {
                        serial "send_to_2"
                        {
                            pv[thisIndex].input_vector_2(write_tag, vec.size(), vec.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation send to certain section of matrix
                    // Helper function to multicast the value to the
                    // destination matrix.
                    when send_to_section_matrix[READ_TAG](
                        int read_tag, int matrix_tag, int dimx, int dimy, CProxy_Matrix pv)
                    {
                        serial "send_to_section_matrix"
                        {
                            int num_of_divisions = 
                                size / aum::sizes::block_size::value_c;
                            
                            if (size % aum::sizes::block_size::value_c != 0)
                                ++num_of_divisions;
                            
                            // Initial dimx
                            int initial_dimx = thisIndex * num_of_divisions;

                            int offset = 0;

                            for (int i = 0; i != num_of_divisions; ++i)
                            {
                                std::vector<CkArrayIndex2D> elems;
                                elems.reserve(dimy);
                                for (int section_dimy = 0; section_dimy != dimy; ++section_dimy)
                                    elems.emplace_back(initial_dimx, section_dimy);
                                
                                CProxySection_Matrix sec =
                                    CProxySection_Matrix::ckNew(pv.ckGetArrayID(), elems);
                                

                                // Is this the very last element and it's not
                                // fully aligned with the offset?
                                if ((size - offset) / aum::sizes::block_size::value_c == 0)
                                {
                                    part_vector_msg* msg =
                                        new part_vector_msg(sec, (size - offset), vec.data() + offset);
                                    CkSetRefNum(msg, matrix_tag);
                                    sec.part_vector(msg);
                                }
                                else
                                {
                                    part_vector_msg* msg =
                                        new part_vector_msg(sec, aum::sizes::block_size::value_c, vec.data() + offset);
                                    CkSetRefNum(msg, matrix_tag);
                                    sec.part_vector(msg);
                                }
                                
                                offset += aum::sizes::block_size::value_c;
                                ++initial_dimx;
                            }

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation exit
                    // Helper function that exits the program when called.
                    when exit[READ_TAG](int read_tag)
                    {
                        serial "exit"
                        {
                            ckout << "Exiting..." << endl;

                            CkExit();
                        }
                    }

                    // Operation exit
                    // Helper function that prints the time taken to execute
                    // up to this point in the program and then exits.
                    when exit[READ_TAG](int read_tag, double start)
                    {
                        serial "exit_with_timer"
                        {
                            double end = CkWallTimer();

                            ckout << "Execution Time: " << end - start << endl;
                            ckout << "Exiting..." << endl;
                            CkExit();
                        }
                    }
                }
            }
        }

        entry void add(int);
        entry void plus_add(int);
        entry void subtract(int);
        entry void minus_subtract(int, bool);
        entry void dot(int, int, CProxy_Scalar);
        entry void scalar_multiply(int, double);
        entry void aum_scalar_multiply(int);
        entry void assemble_reduced(int, int, int size, double arr[size]);
        entry void input_vector_1(int, double);
        entry void input_vector_1(int, int size, double arr[size]);
        entry void input_vector_2(int, int size, double arr[size]);
        entry void send_to_1(int, int, CProxy_Vector);
        entry void send_to_2(int, int, CProxy_Vector);
        entry void send_to_section_matrix(int, int, int, int, CProxy_Matrix);
        entry void exit(int);
        entry void exit(int, double);
    }
}
