// Copyright (C) 2022 Nikunj Gupta
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
//  Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along
// with this program. If not, see <https://www.gnu.org/licenses/>.

module Vector
{
    include "eigen3/Eigen/Core";

    extern module Scalar;

    array[1D] Vector
    {
        ////////////////////////////////////////////////////////////////////////
        // Basic Constructors                                                 //
        ////////////////////////////////////////////////////////////////////////
        entry Vector(int);  // Size, Should construct?
        entry Vector(int, double);  // Size, Value

        ////////////////////////////////////////////////////////////////////////
        // Operation over vector                                              //
        ////////////////////////////////////////////////////////////////////////
        entry void initialize_operation()
        {
            for (; WRITE_TAG > -1;)
            {
                case
                {
                    // Operation Add:
                    // The generalized addition operation takes two vectors
                    // as arguments and updates the current vector with the
                    // sum of the two vectors.
                    when
                        add[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1]),
                        input_vector_2[WRITE_TAG](int write_tag, int size2, double arr2[size2])
                    {
                        serial "vector_addition"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);
                            evec_t e2(arr2, size2);

                            evec_t e(vec.data(), vec.size());

                            e = e1 + e2;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation Add:
                    // The generalized addition operation takes one vector
                    // as argument and updates the current vector.
                    when
                        plus_add[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1])
                    {
                        serial "vector_single_addition"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);

                            evec_t e(vec.data(), vec.size());

                            e += e1;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation Subtract:
                    // The generalized subtraction operation takes two vectors
                    // as arguments and updates the current vector with the
                    // sum of the two vectors.
                    when
                        subtract[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1]),
                        input_vector_2[WRITE_TAG](int write_tag, int size2, double arr2[size2])
                    {
                        serial "vector_subtraction"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);
                            evec_t e2(arr2, size2);

                            evec_t e(vec.data(), vec.size());

                            e = e1 - e2;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation subtract:
                    // The generalized subtraction operation takes one vector
                    // as argument and updates the current vector.
                    when
                        minus_subtract[WRITE_TAG](int write_tag, bool inverted),
                        input_vector_1[WRITE_TAG](int write_tag, int size1, double arr1[size1])
                    {
                        serial "vector_single_subtraction"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr1, size1);

                            evec_t e(vec.data(), vec.size());

                            if (inverted)
                                e = e1 - e;
                            else
                                e -= e1;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation dot:
                    // The generalized index wise multiply then reduce
                    when
                        dot[READ_TAG](int read_tag, int scalar_tag, CProxy_Scalar proxy),
                        input_vector_1[READ_TAG](int read_tag, int size, double arr[size])
                    {
                        serial "dot_product"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            evec_t e1(arr, size);
                            evec_t e(vec.data(), vec.size());

                            double val = e.dot(e1);

                            CkCallback cb(CkReductionTarget(Scalar, set_reduced_value), proxy);
                            contribute(sizeof(double), &val, CkReduction::sum_double, cb, scalar_tag);

                            // Since dot produce isn't updating the vector
                            // itself, we consider this operation as a read and
                            // not a write.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation scalar multiply:
                    // The generalized index wise scalar multiply
                    when
                        scalar_multiply[WRITE_TAG](int write_tag, double value),
                        input_vector_1[WRITE_TAG](int write_tag, int size, double arr[size])
                    {
                        serial "scalar_multiply"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;
                        
                            evec_t e(vec.data(), vec.size());
                            evec_t e1(arr, size);

                            e = value * e1;

                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation scalar multiply:
                    // The generalized index wise scalar multiply
                    when
                        aum_scalar_multiply[WRITE_TAG](int write_tag),
                        input_vector_1[WRITE_TAG](int write_tag, int size, double arr[size]),
                        input_vector_1[WRITE_TAG](int write_tag, double value)
                    {
                        serial "aum_scalar_multiply"
                        {
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;
                        
                            evec_t e(vec.data(), vec.size());
                            evec_t e1(arr, size);

                            e = value * e1;

                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }                    

                    // Operation send_to_1:
                    // Helper function to send the value of underlying vector
                    // to the site where an operation is to be performed.
                    when send_to_1[READ_TAG](int read_tag, int write_tag, CProxy_Vector pv)
                    {
                        serial "send_to_1"
                        {
                            pv[thisIndex].input_vector_1(write_tag, vec.size(), vec.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation send_to_2:
                    // Helper function to send the value of underlying vector
                    // to the site where an operation is to be performed.
                    when send_to_2[READ_TAG](int read_tag, int write_tag, CProxy_Vector pv)
                    {
                        serial "send_to_2"
                        {
                            pv[thisIndex].input_vector_2(write_tag, vec.size(), vec.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation exit
                    // Helper function that exits the program when called.
                    when exit[READ_TAG](int read_tag)
                    {
                        serial "exit"
                        {
                            ckout << "Exiting..." << endl;

                            CkExit();
                        }
                    }

                    // Operation exit
                    // Helper function that prints the time taken to execute
                    // up to this point in the program and then exits.
                    when exit[READ_TAG](int read_tag, double start)
                    {
                        serial "exit_with_timer"
                        {
                            double end = CkWallTimer();

                            ckout << "Execution Time: " << end - start << endl;
                            ckout << "Exiting..." << endl;
                            CkExit();
                        }
                    }
                }
            }
        }

        entry void add(int);
        entry void plus_add(int);
        entry void subtract(int);
        entry void minus_subtract(int, bool);
        entry void dot(int, int, CProxy_Scalar);
        entry void scalar_multiply(int, double);
        entry void aum_scalar_multiply(int);
        entry void input_vector_1(int, double);
        entry void input_vector_1(int, int size, double arr[size]);
        entry void input_vector_2(int, int size, double arr[size]);
        entry void send_to_1(int, int, CProxy_Vector);
        entry void send_to_2(int, int, CProxy_Vector);
        entry void exit(int);
        entry void exit(int, double);
    }
}
