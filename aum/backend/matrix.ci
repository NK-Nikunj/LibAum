// Copyright (C) 2022 Nikunj Gupta
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
//  Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along
// with this program. If not, see <https://www.gnu.org/licenses/>.

module Matrix
{
    include "eigen3/Eigen/Core";

    include "aum/util/sizes.hpp";

    extern module Scalar;
    extern module Vector;

    extern message part_vector_msg;


    array[2D] Matrix
    {
        ////////////////////////////////////////////////////////////////////////
        // Basic Constructors                                                 //
        ////////////////////////////////////////////////////////////////////////
        entry Matrix(int, int, int, int);     // DimX, DimY, NumX, NumY
        
        // Constructor Args: DimX, DimY, Value, NumX, NumY
        entry Matrix(int, int, double, int, int);

        // DimX, DimY, NumX, NumY, Random Initialization
        entry Matrix(int, int, int, int, aum::random);

        ////////////////////////////////////////////////////////////////////////
        // Operation over Matrix                                              //
        ////////////////////////////////////////////////////////////////////////
        entry void initialize_operation()
        {
            for (; WRITE_TAG > -1;)
            {
                case
                {
                    // Operation Add:
                    // The generalized addition operation takes two matrices
                    // as arguments and updates the current vector with the
                    // sum of the two matrices.
                    when
                        add[WRITE_TAG](int write_tag),
                        input_matrix_1[WRITE_TAG](int write_tag, int dimx1, int dimy1, int size1, double arr1[size1]),
                        input_matrix_2[WRITE_TAG](int write_tag, int dimx2, int dimy2, int size2, double arr2[size2])
                    {
                        serial "matrix_addition"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;

                            emat_t e1(arr1, dimy1, dimx1);
                            emat_t e2(arr2, dimy1, dimx1);

                            emat_t e(mat.data(), dimy, dimx);

                            e = e1 + e2;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation Add:
                    // The generalized addition operation takes one matrix
                    // as argument and updates the current matrix.
                    when
                        plus_add[WRITE_TAG](int write_tag),
                        input_matrix_1[WRITE_TAG](int write_tag, int dimx1, int dimy1, int size1, double arr1[size1])
                    {
                        serial "matrix_single_addition"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;

                            emat_t e1(arr1, dimy1, dimx1);

                            emat_t e(mat.data(), dimy, dimx);

                            e += e1;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation Subtract:
                    // The generalized subtraction operation takes two matrices
                    // as arguments and updates the current vector with the
                    // sum of the two matrices.
                    when
                        subtract[WRITE_TAG](int write_tag),
                        input_matrix_1[WRITE_TAG](int write_tag, int dimx1, int dimy1, int size1, double arr1[size1]),
                        input_matrix_2[WRITE_TAG](int write_tag, int dimx2, int dimy2, int size2, double arr2[size2])
                    {
                        serial "matrix_subtraction"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;

                            emat_t e1(arr1, dimy1, dimx1);
                            emat_t e2(arr2, dimy1, dimx1);

                            emat_t e(mat.data(), dimy, dimx);

                            e = e1 - e2;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation Add:
                    // The generalized addition operation takes one vector
                    // as argument and updates the current vector.
                    when
                        minus_subtract[WRITE_TAG](int write_tag, bool inverted),
                        input_matrix_1[WRITE_TAG](int write_tag, int dimx1, int dimy1, int size1, double arr1[size1])
                    {
                        serial "matrix_single_subtraction"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;

                            emat_t e1(arr1, dimy1, dimx1);

                            emat_t e(mat.data(), dimy, dimx);

                            if (inverted)
                                e = e1 - e;
                            else
                                e -= e1;
                            
                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation scalar multiply:
                    // The generalized index wise scalar multiply
                    when
                        scalar_multiply[WRITE_TAG](int write_tag, double value),
                        input_matrix_1[WRITE_TAG](int write_tag, int dimx1, int dimy1, int size1, double arr1[size1])
                    {
                        serial "scalar_multiply"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;

                            emat_t e1(arr1, dimy1, dimx1);

                            emat_t e(mat.data(), dimy, dimx);

                            e = value * e1;

                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }

                    // Operation scalar multiply:
                    // The generalized index wise scalar multiply
                    when
                        aum_scalar_multiply[WRITE_TAG](int write_tag),
                        input_matrix_1[WRITE_TAG](int write_tag, int dimx1, int dimy1, int size1, double arr1[size1]),
                        input_matrix_1[WRITE_TAG](int write_tag, double value)
                    {
                        serial "aum_scalar_multiply"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;

                            emat_t e1(arr1, dimy1, dimx1);

                            emat_t e(mat.data(), dimy, dimx);

                            e = value * e1;

                            // Operation is now complete - set up read facility
                            // on this data.
                            ++WRITE_TAG;
                            READ_TAG = WRITE_TAG + 1;
                        }
                    }  

                    // Operation matrix-vector multiply
                    // The generalized matrix-vector multiply
                    when
                        matrix_vector_multiply[READ_TAG](int read_tag, int vector_tag, CProxy_Vector proxy),
                        part_vector_for_mvm[READ_TAG](part_vector_msg* msg)
                    {
                        serial "matrix_vector_multiply"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;
                            using evec_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, 1>>;

                            emat_t em(mat.data(), dimy, dimx);
                            evec_t ev(msg->arr, msg->size);

                            std::vector<double> res(msg->size);
                            evec_t eres(res.data(), msg->size);
                            eres = em * ev;

                            // Figure out the offset and send a reduction!
                            int num_elems_before = thisIndex.x * aum::sizes::block_size::value_c;
                            int offset = 
                                (num_elems_before % aum::sizes::array_size::value) / aum::sizes::block_size::value_c;
                            int send_index = num_elems_before / aum::sizes::array_size::value;

                            proxy(send_index).assemble_reduced(vector_tag, offset, res.size(), res.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation matrix-vector multiply
                    // The generalized matrix-vector multiply
                    when
                        vector_matrix_multiply[READ_TAG](int read_tag, int vector_tag, CProxy_Vector proxy),
                        part_vector_for_vmm[READ_TAG](part_vector_msg* msg)
                    {
                        serial "vector_matrix_multiply"
                        {
                            using emat_t = Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>;
                            using evec_t = Eigen::Map<Eigen::Matrix<double, 1, Eigen::Dynamic>>;

                            emat_t em(mat.data(), dimy, dimx);
                            evec_t ev(msg->arr, msg->size);


                            std::vector<double> res(msg->size);
                            evec_t eres(res.data(), msg->size);
                            eres = ev * em;

                            // Figure out the offset and send a reduction!
                            int num_elems_before = thisIndex.y * aum::sizes::block_size::value_r;
                            int offset = 
                                (num_elems_before % aum::sizes::array_size::value) / aum::sizes::block_size::value_r;
                            int send_index = num_elems_before / aum::sizes::array_size::value;

                            proxy(send_index).assemble_reduced(vector_tag, offset, res.size(), res.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation send_to_1:
                    // Helper function to send the value of underlying vector
                    // to the site where an operation is to be performed.
                    when send_to_1[READ_TAG](int read_tag, int write_tag, CProxy_Matrix pv)
                    {
                        serial "send_to_1"
                        {
                            pv(thisIndex.x, thisIndex.y).input_matrix_1(write_tag, dimx, dimy, mat.size(), mat.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation send_to_2:
                    // Helper function to send the value of underlying vector
                    // to the site where an operation is to be performed.
                    when send_to_2[READ_TAG](int read_tag, int write_tag, CProxy_Matrix pv)
                    {
                        serial "send_to_2"
                        {
                            pv(thisIndex.x, thisIndex.y).input_matrix_2(write_tag, dimx, dimy, mat.size(), mat.data());

                            // Another read occured. Update write tag by one so
                            // when write operation is called with 
                            // (read_tag + num of writes) it calls the
                            // appropriate operation.
                            ++WRITE_TAG;
                        }
                    }

                    // Operation exit
                    // Helper function that exits the program when called.
                    when exit[READ_TAG](int read_tag)
                    {
                        serial "exit"
                        {
                            ckout << "Exiting..." << endl;

                            CkExit();
                        }
                    }

                    // Operation exit
                    // Helper function that prints the time taken to execute
                    // up to this point in the program and then exits.
                    when exit[READ_TAG](int read_tag, double start)
                    {
                        serial "exit_with_timer"
                        {
                            double end = CkWallTimer();

                            ckout << "Execution Time: " << end - start << endl;
                            ckout << "Exiting..." << endl;
                            CkExit();
                        }
                    }
                }
            }
        }

        entry void add(int);
        entry void plus_add(int);
        entry void subtract(int);
        entry void minus_subtract(int, bool);
        entry void scalar_multiply(int, double);
        entry void aum_scalar_multiply(int);
        entry void matrix_vector_multiply(int, int, CProxy_Vector);
        entry void vector_matrix_multiply(int, int, CProxy_Vector);
        entry void input_matrix_1(int, double);
        entry void input_matrix_1(int, int, int, int size, double arr[size]);
        entry void input_matrix_2(int, int, int, int size, double arr[size]);
        entry void part_vector_for_mvm(part_vector_msg*);
        entry void part_vector_for_vmm(part_vector_msg*);
        entry void send_to_1(int, int, CProxy_Matrix);
        entry void send_to_2(int, int, CProxy_Matrix);
        entry void exit(int);
        entry void exit(int, double);
    }
}
